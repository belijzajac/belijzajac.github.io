<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>belijzajac.dev</title><link>https://belijzajac.dev/</link><description>Recent content on belijzajac.dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>blog@belijzajac.dev (belijzajac)</managingEditor><webMaster>blog@belijzajac.dev (belijzajac)</webMaster><copyright>Copyright © 2024 | CC BY-NC-SA 4.0</copyright><lastBuildDate>Sat, 27 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://belijzajac.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Proto-Danksharding: Speeding Up Blobs Verification</title><link>https://belijzajac.dev/proto-danksharding-speeding-up-blobs-verification/</link><pubDate>Sat, 27 May 2023 00:00:00 +0000</pubDate><author>blog@belijzajac.dev (belijzajac)</author><guid>https://belijzajac.dev/proto-danksharding-speeding-up-blobs-verification/</guid><description>&lt;p>&lt;img src="https://belijzajac.dev/post-images/protodanksharding.jpg" alt="protodanksharding">&lt;/p>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>The Ethereum Foundation proposed &lt;highlight>&lt;a href="https://eips.ethereum.org/EIPS/eip-4844">EIP-4844&lt;/a>&lt;/highlight> on February 25, 2022, with the objective of reducing gas fees. It introduces a new transaction type called &amp;ldquo;blob&amp;rdquo;, which is temporarily stored and committed using the KZG commitment scheme. In addition, the Ethereum Foundation developed a project called &lt;highlight>&lt;a href="https://github.com/ethereum/c-kzg-4844">c-kzg-4844&lt;/a>&lt;/highlight>, which provides a minimal implementation of the polynomial commitments API written in C. This project does not use parallelization and exposes its C API for bindings in different programming languages. Another project, called &lt;highlight>&lt;a href="https://github.com/crate-crypto/go-kzg-4844">go-kzg-4844&lt;/a>&lt;/highlight>, which uses parallelism, has been practically implemented into the Ethereum code and is rumored to be the fastest implementation of EIP-4844 thus far.&lt;/p>
&lt;p>Next week, I will be defending my thesis titled &amp;ldquo;Parallelization of the KZG10 scheme&amp;rdquo;. In my thesis, I parallelized the KZG commitment scheme and BLS12-381 elliptic curve operations, along with a subset of the EIP-4844 proposal that uses these KZG commitments. My changes were incorporated into the &lt;highlight>&lt;a href="https://github.com/grandinetech/rust-kzg">rust-kzg project&lt;/a>&lt;/highlight>, where we exported C functions through Rust to bind the parallelized functions of rust-kzg backends to those of c-kzg-4844. Fortunately, we were presented with a unique opportunity due to the go binding included in the c-kzg-4844 project. We then used this binding to benchmark our rust-kzg&amp;rsquo;s highly parallelized blst backend against their go-kzg-4844 project and assess its speed in comparison.&lt;/p>
&lt;h2 id="how-c-kzg-4844-does-things">How c-kzg-4844 does things&lt;/h2>
&lt;p>C-kzg-4844 leaves the implementation of parallelism to higher-level programming languages that use its bindings. This approach is not only simpler but also safer. The focus of c-kzg-4844 is on single-core performance, which is great for a low-latency environment.&lt;/p>
&lt;h2 id="how-go-kzg-4844-does-things">How go-kzg-4844 does things&lt;/h2>
&lt;p>Go-kzg-4844 offers the function &lt;code>VerifyBlobKZGProofBatch&lt;/code>, which is designed for single-core execution similar to c-kzg-4844. However, they also provide a parallelized version of this function called &lt;code>VerifyBlobKZGProofBatchPar&lt;/code>. This parallelized version uses go-routines to process each proof in parallel. Although not perfect, this parallel implementation is considerably faster than the sequential one.&lt;/p>
&lt;h2 id="how-we-do-things-in-rust-kzg">How we do things in rust-kzg&lt;/h2>
&lt;p>The general idea behind our approach is as follows: if the number of blobs exceeds the number of physical CPU cores, we divide the blobs into subgroups of equal size. Each CPU core then independently runs the batched algorithm. For example, consider the illustration below. If there are 64 blobs and 4 CPU cores, we create 4 groups, each containing 16 blobs. Each group is assigned to its dedicated CPU core, which handles the execution of the blob verification process. By utilizing this approach, we effectively distribute the workload across multiple CPU cores, optimizing performance and ensuring efficient verification of the blobs.&lt;/p>
&lt;p>&lt;img src="https://belijzajac.dev/post-images/batched-blob-verification-approach.png" alt="batched-blob-verification-process">&lt;/p>
&lt;p>However, one could argue that the performance of batched blob KZG proof verification depends on how Ethereum protocol execution clients choose to utilize this approach. If clients choose to verify blobs as soon as they receive them, they would likely opt for an approach that performs single blob verification faster. However, if they decide to wait and accumulate a fixed amount of blobs before performing the verification, this approach will yield much better performance.&lt;/p>
&lt;h2 id="code-example">Code example&lt;/h2>
&lt;p>In the code snippet, there is more to the implementation, but let&amp;rsquo;s focus on illustrating the main concept of this approach:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 1&lt;/span>&lt;span>&lt;span style="color:#8ec07c">#[cfg(feature = &lt;/span>&lt;span style="color:#b8bb26">&amp;#34;parallel&amp;#34;&lt;/span>&lt;span style="color:#8ec07c">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 2&lt;/span>&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 3&lt;/span>&lt;span> &lt;span style="color:#fe8019">let&lt;/span> num_blobs &lt;span style="color:#fe8019">=&lt;/span> blobs.len();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 4&lt;/span>&lt;span> &lt;span style="color:#fe8019">let&lt;/span> num_cores &lt;span style="color:#fe8019">=&lt;/span> num_cpus::get_physical();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 5&lt;/span>&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 6&lt;/span>&lt;span> &lt;span style="color:#fe8019">return&lt;/span> &lt;span style="color:#fe8019">if&lt;/span> num_blobs &lt;span style="color:#fe8019">&amp;gt;&lt;/span> num_cores {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 7&lt;/span>&lt;span> &lt;span style="color:#928374;font-style:italic">// Process blobs in parallel subgroups
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 8&lt;/span>&lt;span>&lt;span style="color:#928374;font-style:italic">&lt;/span> &lt;span style="color:#fe8019">let&lt;/span> blobs_per_group &lt;span style="color:#fe8019">=&lt;/span> num_blobs &lt;span style="color:#fe8019">/&lt;/span> num_cores;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 9&lt;/span>&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">10&lt;/span>&lt;span> blobs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">11&lt;/span>&lt;span> .par_chunks(blobs_per_group)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">12&lt;/span>&lt;span> .enumerate()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">13&lt;/span>&lt;span> .all(&lt;span style="color:#fe8019">|&lt;/span>(i, blob_group)&lt;span style="color:#fe8019">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">14&lt;/span>&lt;span> &lt;span style="color:#fe8019">let&lt;/span> num_blobs_in_group &lt;span style="color:#fe8019">=&lt;/span> blob_group.len();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">15&lt;/span>&lt;span> &lt;span style="color:#fe8019">let&lt;/span> commitment_group &lt;span style="color:#fe8019">=&lt;/span> &lt;span style="color:#fe8019">&amp;amp;&lt;/span>commitments_g1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">16&lt;/span>&lt;span> [blobs_per_group &lt;span style="color:#fe8019">*&lt;/span> i&lt;span style="color:#fe8019">..&lt;/span>blobs_per_group &lt;span style="color:#fe8019">*&lt;/span> i &lt;span style="color:#fe8019">+&lt;/span> num_blobs_in_group];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">17&lt;/span>&lt;span> &lt;span style="color:#fe8019">let&lt;/span> proof_group &lt;span style="color:#fe8019">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">18&lt;/span>&lt;span> &lt;span style="color:#fe8019">&amp;amp;&lt;/span>proofs_g1[blobs_per_group &lt;span style="color:#fe8019">*&lt;/span> i&lt;span style="color:#fe8019">..&lt;/span>blobs_per_group &lt;span style="color:#fe8019">*&lt;/span> i &lt;span style="color:#fe8019">+&lt;/span> num_blobs_in_group];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">19&lt;/span>&lt;span> &lt;span style="color:#fe8019">let&lt;/span> (evaluation_challenges_fr, ys_fr) &lt;span style="color:#fe8019">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">20&lt;/span>&lt;span> compute_challenges_and_evaluate_polynomial(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">21&lt;/span>&lt;span> blob_group,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">22&lt;/span>&lt;span> commitment_group,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">23&lt;/span>&lt;span> ts,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">24&lt;/span>&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">25&lt;/span>&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">26&lt;/span>&lt;span> verify_kzg_proof_batch(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">27&lt;/span>&lt;span> commitment_group,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">28&lt;/span>&lt;span> &lt;span style="color:#fe8019">&amp;amp;&lt;/span>evaluation_challenges_fr,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">29&lt;/span>&lt;span> &lt;span style="color:#fe8019">&amp;amp;&lt;/span>ys_fr,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">30&lt;/span>&lt;span> proof_group,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">31&lt;/span>&lt;span> ts,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">32&lt;/span>&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">33&lt;/span>&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">34&lt;/span>&lt;span> } &lt;span style="color:#fe8019">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">35&lt;/span>&lt;span> &lt;span style="color:#928374;font-style:italic">// Each group contains either one or zero blobs, so iterate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">36&lt;/span>&lt;span>&lt;span style="color:#928374;font-style:italic">&lt;/span> &lt;span style="color:#928374;font-style:italic">// over the single blob verification function in parallel
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">37&lt;/span>&lt;span>&lt;span style="color:#928374;font-style:italic">&lt;/span> (blobs, commitments_g1, proofs_g1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">38&lt;/span>&lt;span> .into_par_iter()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">39&lt;/span>&lt;span> .all(&lt;span style="color:#fe8019">|&lt;/span>(blob, commitment, proof)&lt;span style="color:#fe8019">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">40&lt;/span>&lt;span> verify_blob_kzg_proof(blob, commitment, proof, ts)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">41&lt;/span>&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">42&lt;/span>&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">43&lt;/span>&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When &lt;code>num_blobs &amp;gt; num_cores&lt;/code>, the code divides the blobs into parallel subgroups. The number of blobs per group is calculated based on the division. The code then iterates over each subgroup, performing various operations such as retrieving the corresponding commitment and proof groups. It also computes evaluation challenges and evaluates a polynomial using the provided data. Finally, it verifies a batch of KZG proofs using the obtained information.&lt;/p>
&lt;p>In the else statement, when the number of blobs is not greater than the number of cores, the code handles each blob individually or in groups with only one blob. It uses parallel iteration to execute the blob verification function concurrently, similar to how go-kzg-4844 handles parallelism using go-routines.&lt;/p>
&lt;h2 id="results">Results&lt;/h2>
&lt;p>&lt;img src="https://belijzajac.dev/post-images/batched-blob-verification-results.png" alt="batched-blob-verification-results">&lt;/p>
&lt;p>Rust and Go bindings, using the rust-kzg with blst backend, verified 64 blobs on 16 cores in 29.82 ms and 30.164 ms, respectively. In comparison, the native rust-kzg accomplished this task in 18.397 ms, while the parallelized implementation of go-kzg-4844 took 48.037 ms. It’s important to note that we only perform full error checking through the exported C API when we convert bytes to our internal types. Therefore, the performance of the native rust-kzg code is probably better because we omit those checks here, assuming we receive correct data from the byte conversion functions. With this in mind, the &lt;highlight>rust-kzg with blst backend outperformed go-kzg-4844 by approximately 161.11% in terms of speed, while its bindings were approximately 59.25% faster&lt;/highlight>.&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;ul>
&lt;li>We potentially outperform go-kzg-4844 by approximately 59.25% within Go in batched blob KZG proof verification&lt;/li>
&lt;/ul></description></item><item><title>WisniaLang: Compiler Project</title><link>https://belijzajac.dev/wisnialang-compiler-project/</link><pubDate>Mon, 17 Oct 2022 00:00:00 +0000</pubDate><author>blog@belijzajac.dev (belijzajac)</author><guid>https://belijzajac.dev/wisnialang-compiler-project/</guid><description>&lt;p>&lt;img src="https://belijzajac.dev/post-images/dragon-maid-compiler-book.jpg" alt="dragon-book">&lt;/p>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>For the past 3 years, I have been working on the &lt;highlight>&lt;a href="https://github.com/belijzajac/WisniaLang">WisniaLang&lt;/a>&lt;/highlight> compiler for my own programming language that compiles to native machine code and packs it into an executable by itself. Unlike many others, I rolled out my own compiler backend from scratch that does fast but naive code generation. While it&amp;rsquo;s admittedly a more old-fashioned approach to compiler engineering, it&amp;rsquo;s the path I chose to take when developing my compiler.&lt;/p>
&lt;p>Many in the field rely on LLVM Intermediate Representation (IR) for their compilers, which can feel somewhat like cheating. Essentially, they’re just tapping into LLVM’s optimizations and claiming ownership of the result. Then they compare their LLVM-based language #5646545 to another LLVM-based language #5646698, touting superior benchmark results, all while benefiting from LLVM’s optimizations. Truly, the LLVM project has a lot of man hours poured into optimizations. Interestingly, I have heard that even established compilers like those for Fortran are switching over to LLVM, following the trend.&lt;/p>
&lt;h2 id="architecture">Architecture&lt;/h2>
&lt;p>&lt;img src="https://belijzajac.dev/post-images/wisnialang-architecture.png" alt="architecture">&lt;/p>
&lt;p>My compiler&amp;rsquo;s architecture is divided into several main phases that work together to complete this translation. These phases include lexical analysis, which breaks the source code down into smaller pieces called tokens; syntactic analysis, which builds a representation of the structure of the source code called an abstract syntax tree (AST); semantic analysis, which checks the AST for semantic errors while traversing the tree; intermediate representation (IR), which represents the code in a lower-level form close to the target architecture; code generation, which allocates registers and generates machine code from the said IRs; and, lastly, packing the resulting machine code into an executable program in ELF format.&lt;/p>
&lt;h2 id="programming-languages-and-llvm">Programming languages and LLVM&lt;/h2>
&lt;p>Before going further, let me get straight to the point:&lt;/p>
&lt;ol>
&lt;li>Writing compilers is easy&lt;/li>
&lt;li>Optimizing the machine code is hard&lt;/li>
&lt;li>Supporting arbitrary architectures / operating systems is hard&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://belijzajac.dev/post-images/llvm-approach.png" alt="llvm-approach">&lt;/p>
&lt;p>This is where LLVM comes in handy. LLVM uses an intermediate representation language, which is kind of similar to assembly, but with a few higher level constructs. LLVM is good at optimizing this IR language, as well as compiling into different architecture and binary formats. So as a language author using LLVM, I&amp;rsquo;m really writing a transpiler from my language to LLVM IR, and letting the LLVM compiler do the hard work.&lt;/p>
&lt;hr>
&lt;p>You talk about LLVM so much, why&amp;rsquo;s that? Let me begin with this illustration:&lt;/p>
&lt;p>&lt;img src="https://belijzajac.dev/post-images/llvm-family.png" alt="llvm-family">&lt;/p>
&lt;p>I&amp;rsquo;m not sure if it&amp;rsquo;s a positive thing, but the LLVM project has achieved such widespread adoption that it&amp;rsquo;s almost reached a monopoly status, much like the Chromium project, for instance. Apart from Google Chrome, numerous other browsers are built upon the Chromium codebase. From Electron web apps to Arc, Microsoft Edge, Opera, Vivaldi, Brave, and beyond, the list just goes on. Firefox and Safari are perhaps the only web browsers that stand out from this copy-paste crowd.&lt;/p>
&lt;p>I just wanted to point out that while 99.9% of compiler developers opt for LLVM, the remaining few explore alternative compiler backends like &lt;highlight>&lt;a href="https://c9x.me/compile/">QBE&lt;/a>&lt;/highlight>, develop interpreters (like Python), or create virtual machines (such as the JVM for Java and Kotlin). Some even write transpilers that convert high-level languages into something low-level like C, which is then compiled with gcc. If you recall the dragon compiler book appearing at the top of this page, these and similar compiler books are gradually losing relevance because they don&amp;rsquo;t teach how to use LLVM, the industry&amp;rsquo;s compiler standard.&lt;/p>
&lt;h2 id="performing-benchmarks">Performing benchmarks&lt;/h2>
&lt;p>To benchmark different compilers, I chose the Fibonacci sequence without recursion problem and computed the 46th Fibonacci number with each compiler under test. This number was chosen because it conveniently fits within 32 bits. Compile-time and runtime benchmarks were performed using the &lt;highlight>&lt;a href="https://github.com/sharkdp/hyperfine">hyperfine&lt;/a>&lt;/highlight> command-line benchmarking tool, which closely resembles Rust&amp;rsquo;s &lt;highlight>&lt;a href="https://github.com/bheisler/criterion.rs">Criterion&lt;/a>&lt;/highlight> benchmarking library. Binary size benchmarks were carried out using standard Linux tools like &lt;code>strip&lt;/code> to remove debug symbols from binaries and &lt;code>wc&lt;/code> to display byte counts for each binary file.&lt;/p>
&lt;h3 id="wisnialang-benchmark">WisniaLang benchmark&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 1&lt;/span>&lt;span>&lt;span style="color:#fe8019">fn&lt;/span> &lt;span style="color:#fabd2f">fibonacci&lt;/span>(n: int) -&amp;gt; int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 2&lt;/span>&lt;span> &lt;span style="color:#fe8019">if&lt;/span> (n &lt;span style="color:#fe8019">&amp;lt;=&lt;/span> &lt;span style="color:#d3869b">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 3&lt;/span>&lt;span> &lt;span style="color:#fe8019">return&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 4&lt;/span>&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 5&lt;/span>&lt;span> int prev &lt;span style="color:#fe8019">=&lt;/span> &lt;span style="color:#d3869b">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 6&lt;/span>&lt;span> int current &lt;span style="color:#fe8019">=&lt;/span> &lt;span style="color:#d3869b">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 7&lt;/span>&lt;span> &lt;span style="color:#fe8019">for&lt;/span> (int i &lt;span style="color:#fe8019">=&lt;/span> &lt;span style="color:#d3869b">2&lt;/span>; i &lt;span style="color:#fe8019">&amp;lt;=&lt;/span> n; i &lt;span style="color:#fe8019">=&lt;/span> i &lt;span style="color:#fe8019">+&lt;/span> &lt;span style="color:#d3869b">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 8&lt;/span>&lt;span> int next &lt;span style="color:#fe8019">=&lt;/span> prev &lt;span style="color:#fe8019">+&lt;/span> current;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 9&lt;/span>&lt;span> prev &lt;span style="color:#fe8019">=&lt;/span> current;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">10&lt;/span>&lt;span> current &lt;span style="color:#fe8019">=&lt;/span> next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">11&lt;/span>&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">12&lt;/span>&lt;span> &lt;span style="color:#fe8019">return&lt;/span> current;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">13&lt;/span>&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">14&lt;/span>&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">15&lt;/span>&lt;span>&lt;span style="color:#fe8019">fn&lt;/span> &lt;span style="color:#fabd2f">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">16&lt;/span>&lt;span> print(fibonacci(&lt;span style="color:#d3869b">46&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">17&lt;/span>&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4>Compile time&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>hyperfine --runs &lt;span style="color:#d3869b">1000&lt;/span> --warmup &lt;span style="color:#d3869b">10&lt;/span> --shell&lt;span style="color:#fe8019">=&lt;/span>none &lt;span style="color:#b8bb26">&amp;#39;./wisnia fibonacci.wsn&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>Benchmark 1: ./wisnia fibonacci.wsn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span> Time &lt;span style="color:#fe8019">(&lt;/span>mean ± σ&lt;span style="color:#fe8019">)&lt;/span>: 1.6 ms ± 0.3 ms &lt;span style="color:#fe8019">[&lt;/span>User: 0.8 ms, System: 0.5 ms&lt;span style="color:#fe8019">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span> Range &lt;span style="color:#fe8019">(&lt;/span>min … max&lt;span style="color:#fe8019">)&lt;/span>: 1.3 ms … 8.7 ms &lt;span style="color:#d3869b">1000&lt;/span> runs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4>Runtime&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>hyperfine --runs &lt;span style="color:#d3869b">1000&lt;/span> --warmup &lt;span style="color:#d3869b">10&lt;/span> --shell&lt;span style="color:#fe8019">=&lt;/span>none &lt;span style="color:#b8bb26">&amp;#39;./a.out&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>Benchmark 1: ./a.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span> Time &lt;span style="color:#fe8019">(&lt;/span>mean ± σ&lt;span style="color:#fe8019">)&lt;/span>: 109.6 µs ± 36.8 µs &lt;span style="color:#fe8019">[&lt;/span>User: 58.2 µs, System: 4.7 µs&lt;span style="color:#fe8019">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span> Range &lt;span style="color:#fe8019">(&lt;/span>min … max&lt;span style="color:#fe8019">)&lt;/span>: 84.0 µs … 736.3 µs &lt;span style="color:#d3869b">1000&lt;/span> runs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4>Binary size&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>wc -c a.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>&lt;span style="color:#d3869b">421&lt;/span> a.out
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="c-gcc-benchmark">C++ (gcc) benchmark&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 1&lt;/span>&lt;span>&lt;span style="color:#8ec07c">#include&lt;/span> &lt;span style="color:#8ec07c;font-style:italic">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#8ec07c">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 2&lt;/span>&lt;span>&lt;span style="color:#8ec07c">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 3&lt;/span>&lt;span>&lt;span style="color:#fe8019">constexpr&lt;/span> &lt;span style="color:#fe8019">auto&lt;/span> &lt;span style="color:#fabd2f">fibonacci&lt;/span>(u_int32_t n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 4&lt;/span>&lt;span> &lt;span style="color:#fe8019">if&lt;/span> (n &lt;span style="color:#fe8019">&amp;lt;=&lt;/span> &lt;span style="color:#d3869b">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 5&lt;/span>&lt;span> &lt;span style="color:#fe8019">return&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 6&lt;/span>&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 7&lt;/span>&lt;span> u_int32_t prev &lt;span style="color:#fe8019">=&lt;/span> &lt;span style="color:#d3869b">0&lt;/span>, current &lt;span style="color:#fe8019">=&lt;/span> &lt;span style="color:#d3869b">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 8&lt;/span>&lt;span> &lt;span style="color:#fe8019">for&lt;/span> (size_t i &lt;span style="color:#fe8019">=&lt;/span> &lt;span style="color:#d3869b">2&lt;/span>; i &lt;span style="color:#fe8019">&amp;lt;=&lt;/span> n; i&lt;span style="color:#fe8019">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 9&lt;/span>&lt;span> u_int32_t next &lt;span style="color:#fe8019">=&lt;/span> prev &lt;span style="color:#fe8019">+&lt;/span> current;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">10&lt;/span>&lt;span> prev &lt;span style="color:#fe8019">=&lt;/span> current;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">11&lt;/span>&lt;span> current &lt;span style="color:#fe8019">=&lt;/span> next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">12&lt;/span>&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">13&lt;/span>&lt;span> &lt;span style="color:#fe8019">return&lt;/span> current;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">14&lt;/span>&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">15&lt;/span>&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">16&lt;/span>&lt;span>&lt;span style="color:#fabd2f">int&lt;/span> &lt;span style="color:#fabd2f">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">17&lt;/span>&lt;span> std&lt;span style="color:#fe8019">::&lt;/span>printf(&lt;span style="color:#b8bb26">&amp;#34;%d&amp;#34;&lt;/span>, fibonacci(&lt;span style="color:#d3869b">46&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">18&lt;/span>&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4>Compile time&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>hyperfine --runs &lt;span style="color:#d3869b">100&lt;/span> --warmup &lt;span style="color:#d3869b">10&lt;/span> --shell&lt;span style="color:#fe8019">=&lt;/span>none &lt;span style="color:#b8bb26">&amp;#39;gcc -std=c++23 -O3 fibonacci.cpp&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>Benchmark 1: gcc -std&lt;span style="color:#fe8019">=&lt;/span>c++23 -O3 fibonacci.cpp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span> Time &lt;span style="color:#fe8019">(&lt;/span>mean ± σ&lt;span style="color:#fe8019">)&lt;/span>: 456.4 ms ± 4.5 ms &lt;span style="color:#fe8019">[&lt;/span>User: 415.8 ms, System: 35.2 ms&lt;span style="color:#fe8019">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span> Range &lt;span style="color:#fe8019">(&lt;/span>min … max&lt;span style="color:#fe8019">)&lt;/span>: 448.9 ms … 472.1 ms &lt;span style="color:#d3869b">100&lt;/span> runs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4>Runtime&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>hyperfine --runs &lt;span style="color:#d3869b">1000&lt;/span> --warmup &lt;span style="color:#d3869b">10&lt;/span> --shell&lt;span style="color:#fe8019">=&lt;/span>none &lt;span style="color:#b8bb26">&amp;#39;./a.out&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>Benchmark 1: ./a.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span> Time &lt;span style="color:#fe8019">(&lt;/span>mean ± σ&lt;span style="color:#fe8019">)&lt;/span>: 347.1 µs ± 62.8 µs &lt;span style="color:#fe8019">[&lt;/span>User: 206.4 µs, System: 67.2 µs&lt;span style="color:#fe8019">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span> Range &lt;span style="color:#fe8019">(&lt;/span>min … max&lt;span style="color:#fe8019">)&lt;/span>: 271.9 µs … 926.4 µs &lt;span style="color:#d3869b">1000&lt;/span> runs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4>Binary size&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>strip a.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>wc -c a.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span>&lt;span style="color:#d3869b">14472&lt;/span> a.out
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="c-clang-benchmark">C++ (clang) benchmark&lt;/h3>
&lt;p>Same program as before, just different compiler.&lt;/p>
&lt;h4>Compile time&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>hyperfine --runs &lt;span style="color:#d3869b">100&lt;/span> --warmup &lt;span style="color:#d3869b">10&lt;/span> --shell&lt;span style="color:#fe8019">=&lt;/span>none &lt;span style="color:#b8bb26">&amp;#39;clang -std=c++2b -O3 fibonacci.cpp&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>Benchmark 1: clang -std&lt;span style="color:#fe8019">=&lt;/span>c++2b -O3 fibonacci.cpp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span> Time &lt;span style="color:#fe8019">(&lt;/span>mean ± σ&lt;span style="color:#fe8019">)&lt;/span>: 538.2 ms ± 16.9 ms &lt;span style="color:#fe8019">[&lt;/span>User: 481.7 ms, System: 45.7 ms&lt;span style="color:#fe8019">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span> Range &lt;span style="color:#fe8019">(&lt;/span>min … max&lt;span style="color:#fe8019">)&lt;/span>: 524.3 ms … 657.9 ms &lt;span style="color:#d3869b">100&lt;/span> runs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4>Runtime&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>hyperfine --runs &lt;span style="color:#d3869b">1000&lt;/span> --warmup &lt;span style="color:#d3869b">10&lt;/span> --shell&lt;span style="color:#fe8019">=&lt;/span>none &lt;span style="color:#b8bb26">&amp;#39;./a.out&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>Benchmark 1: ./a.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span> Time &lt;span style="color:#fe8019">(&lt;/span>mean ± σ&lt;span style="color:#fe8019">)&lt;/span>: 351.4 µs ± 67.7 µs &lt;span style="color:#fe8019">[&lt;/span>User: 203.2 µs, System: 72.2 µs&lt;span style="color:#fe8019">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span> Range &lt;span style="color:#fe8019">(&lt;/span>min … max&lt;span style="color:#fe8019">)&lt;/span>: 267.1 µs … 984.8 µs &lt;span style="color:#d3869b">1000&lt;/span> runs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4>Binary size&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>strip a.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>wc -c a.out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span>&lt;span style="color:#d3869b">14504&lt;/span> a.out
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="rust-benchmark">Rust benchmark&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 1&lt;/span>&lt;span>&lt;span style="color:#fe8019">fn&lt;/span> &lt;span style="color:#fabd2f">fibonacci&lt;/span>(n: &lt;span style="color:#fabd2f">u32&lt;/span>) -&amp;gt; &lt;span style="color:#fabd2f">u32&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 2&lt;/span>&lt;span> &lt;span style="color:#fe8019">if&lt;/span> n &lt;span style="color:#fe8019">&amp;lt;=&lt;/span> &lt;span style="color:#d3869b">1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 3&lt;/span>&lt;span> &lt;span style="color:#fe8019">return&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 4&lt;/span>&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 5&lt;/span>&lt;span> &lt;span style="color:#fe8019">let&lt;/span> (&lt;span style="color:#fe8019">mut&lt;/span> prev, &lt;span style="color:#fe8019">mut&lt;/span> current) &lt;span style="color:#fe8019">=&lt;/span> (&lt;span style="color:#d3869b">0&lt;/span>, &lt;span style="color:#d3869b">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 6&lt;/span>&lt;span> &lt;span style="color:#fe8019">for&lt;/span> _ &lt;span style="color:#fe8019">in&lt;/span> &lt;span style="color:#d3869b">2&lt;/span>&lt;span style="color:#fe8019">..=&lt;/span>n {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 7&lt;/span>&lt;span> &lt;span style="color:#fe8019">let&lt;/span> next &lt;span style="color:#fe8019">=&lt;/span> prev &lt;span style="color:#fe8019">+&lt;/span> current;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 8&lt;/span>&lt;span> prev &lt;span style="color:#fe8019">=&lt;/span> current;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 9&lt;/span>&lt;span> current &lt;span style="color:#fe8019">=&lt;/span> next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">10&lt;/span>&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">11&lt;/span>&lt;span> current
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">12&lt;/span>&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">13&lt;/span>&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">14&lt;/span>&lt;span>&lt;span style="color:#fe8019">fn&lt;/span> &lt;span style="color:#fabd2f">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">15&lt;/span>&lt;span> println!(&lt;span style="color:#b8bb26">&amp;#34;&lt;/span>&lt;span style="color:#b8bb26">{}&lt;/span>&lt;span style="color:#b8bb26">&amp;#34;&lt;/span>, fibonacci(&lt;span style="color:#d3869b">46&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">16&lt;/span>&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4>Compile time&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>hyperfine --runs &lt;span style="color:#d3869b">100&lt;/span> --warmup &lt;span style="color:#d3869b">10&lt;/span> --shell&lt;span style="color:#fe8019">=&lt;/span>none &lt;span style="color:#b8bb26">&amp;#39;rustc -C opt-level=3 fibonacci.rs&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>Benchmark 1: rustc -C opt-level&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#d3869b">3&lt;/span> fibonacci.rs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span> Time &lt;span style="color:#fe8019">(&lt;/span>mean ± σ&lt;span style="color:#fe8019">)&lt;/span>: 173.4 ms ± 3.0 ms &lt;span style="color:#fe8019">[&lt;/span>User: 130.5 ms, System: 51.2 ms&lt;span style="color:#fe8019">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span> Range &lt;span style="color:#fe8019">(&lt;/span>min … max&lt;span style="color:#fe8019">)&lt;/span>: 168.6 ms … 183.8 ms &lt;span style="color:#d3869b">100&lt;/span> runs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4>Runtime&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>hyperfine --runs &lt;span style="color:#d3869b">1000&lt;/span> --warmup &lt;span style="color:#d3869b">10&lt;/span> --shell&lt;span style="color:#fe8019">=&lt;/span>none &lt;span style="color:#b8bb26">&amp;#39;./fibonacci&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>Benchmark 1: ./fibonacci
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span> Time &lt;span style="color:#fe8019">(&lt;/span>mean ± σ&lt;span style="color:#fe8019">)&lt;/span>: 490.4 µs ± 82.8 µs &lt;span style="color:#fe8019">[&lt;/span>User: 264.9 µs, System: 129.3 µs&lt;span style="color:#fe8019">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span> Range &lt;span style="color:#fe8019">(&lt;/span>min … max&lt;span style="color:#fe8019">)&lt;/span>: 375.1 µs … 1092.6 µs &lt;span style="color:#d3869b">1000&lt;/span> runs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4>Binary size&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>strip fibonacci
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>wc -c fibonacci
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span>&lt;span style="color:#d3869b">321920&lt;/span> fibonacci
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="results">Results&lt;/h2>
&lt;p>&lt;img src="https://belijzajac.dev/post-images/benchmark-results.png" alt="wisnialang-vs-rust">&lt;/p>
&lt;p>Combining mean compile time, runtime, and binary sizes from benchmark results, we obtain the following graph. To be honest, I&amp;rsquo;m quite impressed by my compiler&amp;rsquo;s generated binary&amp;rsquo;s runtime performance. However, it&amp;rsquo;s important to acknowledge that the runtime range for WisniaLang was &lt;code>84.0 µs&lt;/code> to &lt;code>736.3 µs&lt;/code> over 1000 program runs, indicating ambiguous results due to benchmarking a program of less than 20 lines of code. In the real world, to accurately assess a compiler backend&amp;rsquo;s performance, one would need to run benchmarks on millions of lines of code.&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;ul>
&lt;li>If compilation speed and binary size are important, dropping the LLVM toolchain can have a positive impact&lt;/li>
&lt;li>However, doing so means missing out on LLVM optimizations as well as support for arbitrary OSes and architectures&lt;/li>
&lt;/ul></description></item><item><title>Outperforming Rayon with OpenMP</title><link>https://belijzajac.dev/outperforming-rayon-with-openmp/</link><pubDate>Tue, 16 Nov 2021 00:00:00 +0000</pubDate><author>blog@belijzajac.dev (belijzajac)</author><guid>https://belijzajac.dev/outperforming-rayon-with-openmp/</guid><description>&lt;p>&lt;img src="https://belijzajac.dev/post-images/rip-craberino.jpg" alt="rip-craberino">&lt;/p>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>For the Blockchain Technologies course, students were paired into groups and assigned to produce the fastest Rust library implementing the KZG10 cryptographic scheme. Two teams used the &lt;highlight>&lt;a href="https://github.com/supranational/blst">blst&lt;/a>&lt;/highlight> backend, which is implemented in assembly and has direct bindings for Rust and C. The first team, &lt;highlight>&lt;a href="https://github.com/grandinetech/rust-kzg/tree/main/blst">blst-from-scratch&lt;/a>&lt;/highlight>, used the Rust bindings provided by the blst library to produce an interface closer to &lt;highlight>&lt;a href="https://github.com/benjaminion/c-kzg">c-kzg&lt;/a>&lt;/highlight>. The second team, which I was part of, worked on the &lt;highlight>&lt;a href="https://github.com/grandinetech/rust-kzg/tree/main/ckzg">ckzg&lt;/a>&lt;/highlight> library in C. We were responsible for producing an implementation that could integrate into Rust via the C bindings provided by my team.&lt;/p>
&lt;h2 id="choosing-the-right-tool-for-the-job">Choosing the right tool for the job&lt;/h2>
&lt;p>It&amp;rsquo;s a no-brainer for Rust programmers to choose &lt;code>Rayon&lt;/code> when it comes to writing parallel code, as there aren&amp;rsquo;t many other viable and easy-to-use options available. While Rust does offer alternatives like &lt;code>std::thread&lt;/code>, which provides access to native OS threads, the manual creation and management of threads can be cumbersome.&lt;/p>
&lt;p>When I was working on my C code, I had to decide on the best approach to parallelize it. My options included:&lt;/p>
&lt;ul>
&lt;li>&lt;code>pthread&lt;/code>: A POSIX standard for thread creation and management.&lt;/li>
&lt;li>A popular third-party threadpool library from GitHub.&lt;/li>
&lt;li>&lt;code>OpenMP&lt;/code>: Parallel programming library for C and C++ without manual thread management.&lt;/li>
&lt;/ul>
&lt;p>I chose OpenMP because, during experimentation, I discovered it yielded the best results and was relatively straightforward to use. However, I encountered a challenge in integrating it with Rust to ensure compatibility across multiple platforms, starting with Linux and possibly macOS. Eventually, I came up with the following Bash script to automate the entire process of building and packaging shared libraries. Fortunately, OpenMP was integrated into Rust by either:&lt;/p>
&lt;ul>
&lt;li>exporting the &lt;code>RUSTFLAGS&lt;/code> environment variable pointing to the correct &lt;code>libomp&lt;/code> LLVM runtime&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 1&lt;/span>&lt;span>&lt;span style="color:#928374;font-style:italic"># Linux&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 2&lt;/span>&lt;span>apt install libomp-dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 3&lt;/span>&lt;span>&lt;span style="color:#fabd2f">export&lt;/span> LIBOMP_PATH&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#fe8019">$(&lt;/span>find /usr/lib/llvm* -name libiomp5.so | head -n 1&lt;span style="color:#fe8019">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 4&lt;/span>&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 5&lt;/span>&lt;span>&lt;span style="color:#928374;font-style:italic"># MacOS&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 6&lt;/span>&lt;span>brew install libomp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 7&lt;/span>&lt;span>ln -s /usr/local/opt/libomp/lib/libomp.dylib /usr/local/lib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 8&lt;/span>&lt;span>ln -s /usr/local/opt/libomp/include/omp.h /usr/local/include
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 9&lt;/span>&lt;span>&lt;span style="color:#fabd2f">export&lt;/span> LIBOMP_PATH&lt;span style="color:#fe8019">=&lt;/span>/usr/local/lib/libomp.dylib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">10&lt;/span>&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">11&lt;/span>&lt;span>&lt;span style="color:#928374;font-style:italic"># And finally&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">12&lt;/span>&lt;span>&lt;span style="color:#fabd2f">export&lt;/span> RUSTFLAGS&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#b8bb26">&amp;#34;-C link-arg=&lt;/span>$LIBOMP_PATH&lt;span style="color:#b8bb26">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>or creating a &lt;code>.cargo/config.toml&lt;/code> file inside the project directory and mentioning it there&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>[build]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>rustflags = [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span> &amp;#34;-C&amp;#34;, &amp;#34;link-arg=LIBOMP_PATH&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Well, that was simple.&lt;/p>
&lt;h2 id="searching-for-bottlenecks">Searching for bottlenecks&lt;/h2>
&lt;p>In order to optimize a program&amp;rsquo;s performance, CPU profiling tools like &lt;code>Perf&lt;/code> play a crucial role by providing detailed insights into where computational resources are being used. One powerful visualization tool generated by these profilers is the flamegraph, which offers a clear representation of a program&amp;rsquo;s CPU usage over time.&lt;/p>
&lt;p>&lt;img src="https://belijzajac.dev/post-images/flame-graphu.svg" alt="flamegraph-of-fft-g1">&lt;/p>
&lt;p>The flamegraph displayed above illustrates the CPU time distribution of the c-kzg library&amp;rsquo;s &lt;code>fft_g1&lt;/code> benchmark. Upon analysis, it became evident that a significant portion of the execution time was spent in assembly code, highlighting potential areas for optimization. Further investigation on &lt;highlight>&lt;a href="https://github.com/protolambda/go-kzg">go-kzg&lt;/a>&lt;/highlight> revealed that the &lt;code>fft_g1&lt;/code> benchmark was indeed a performance bottleneck and stood out as a prime candidate for parallelization. By parallelizing this specific operation, we can improving the overall performance of the library.&lt;/p>
&lt;h2 id="parallelizing-fft_g1">Parallelizing fft_g1&lt;/h2>
&lt;p>The &lt;code>fft_g1&lt;/code> function calls the &lt;code>fft_g1_fast&lt;/code> function, which applies the &lt;em>divide-and-conquer&lt;/em> principle to divide a large problem into smaller subproblems, recursively solving each of them. The general procedure here is to distribute work (&lt;code>fft_f1_fast&lt;/code>s) among worker threads.&lt;/p>
&lt;p>The blst-from-scratch team implemented it as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 1&lt;/span>&lt;span>&lt;span style="color:#fe8019">let&lt;/span> (lo, hi) &lt;span style="color:#fe8019">=&lt;/span> ret.split_at_mut(half);
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 2&lt;/span>&lt;span>rayon::join(
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 3&lt;/span>&lt;span> &lt;span style="color:#fe8019">||&lt;/span> fft_g1_fast(lo, data, stride &lt;span style="color:#fe8019">*&lt;/span> &lt;span style="color:#d3869b">2&lt;/span>, roots, roots_stride &lt;span style="color:#fe8019">*&lt;/span> &lt;span style="color:#d3869b">2&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 4&lt;/span>&lt;span> &lt;span style="color:#fe8019">||&lt;/span> fft_g1_fast(hi, &lt;span style="color:#fe8019">&amp;amp;&lt;/span>data[stride&lt;span style="color:#fe8019">..&lt;/span>], stride &lt;span style="color:#fe8019">*&lt;/span> &lt;span style="color:#d3869b">2&lt;/span>, roots, roots_stride &lt;span style="color:#fe8019">*&lt;/span> &lt;span style="color:#d3869b">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 5&lt;/span>&lt;span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 6&lt;/span>&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 7&lt;/span>&lt;span>&lt;span style="color:#fe8019">for&lt;/span> i &lt;span style="color:#fe8019">in&lt;/span> &lt;span style="color:#d3869b">0&lt;/span>&lt;span style="color:#fe8019">..&lt;/span>half {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 8&lt;/span>&lt;span> &lt;span style="color:#fe8019">let&lt;/span> y_times_root &lt;span style="color:#fe8019">=&lt;/span> ret[i &lt;span style="color:#fe8019">+&lt;/span> half].mul(&lt;span style="color:#fe8019">&amp;amp;&lt;/span>roots[i &lt;span style="color:#fe8019">*&lt;/span> roots_stride]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 9&lt;/span>&lt;span> ret[i &lt;span style="color:#fe8019">+&lt;/span> half] &lt;span style="color:#fe8019">=&lt;/span> ret[i].sub(&lt;span style="color:#fe8019">&amp;amp;&lt;/span>y_times_root);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">10&lt;/span>&lt;span> ret[i] &lt;span style="color:#fe8019">=&lt;/span> ret[i].add_or_dbl(&lt;span style="color:#fe8019">&amp;amp;&lt;/span>y_times_root);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">11&lt;/span>&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As a side note, &lt;code>rayon::join&lt;/code> spawns two threads, one executing each of the two closures.&lt;/p>
&lt;p>The C equivalent, on the other hand, was as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 1&lt;/span>&lt;span>&lt;span style="color:#8ec07c">#pragma omp parallel sections
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 2&lt;/span>&lt;span>&lt;span style="color:#8ec07c">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 3&lt;/span>&lt;span> &lt;span style="color:#8ec07c">#pragma omp section
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 4&lt;/span>&lt;span>&lt;span style="color:#8ec07c">&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 5&lt;/span>&lt;span> &lt;span style="color:#fabd2f">fft_g1_fast&lt;/span>(out, in, stride &lt;span style="color:#fe8019">*&lt;/span> &lt;span style="color:#d3869b">2&lt;/span>, roots, roots_stride &lt;span style="color:#fe8019">*&lt;/span> &lt;span style="color:#d3869b">2&lt;/span>, half);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 6&lt;/span>&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 7&lt;/span>&lt;span> &lt;span style="color:#8ec07c">#pragma omp section
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 8&lt;/span>&lt;span>&lt;span style="color:#8ec07c">&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 9&lt;/span>&lt;span> &lt;span style="color:#fabd2f">fft_g1_fast&lt;/span>(out &lt;span style="color:#fe8019">+&lt;/span> half, in &lt;span style="color:#fe8019">+&lt;/span> stride, stride &lt;span style="color:#fe8019">*&lt;/span> &lt;span style="color:#d3869b">2&lt;/span>, roots, roots_stride &lt;span style="color:#fe8019">*&lt;/span> &lt;span style="color:#d3869b">2&lt;/span>, half);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">10&lt;/span>&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">11&lt;/span>&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">12&lt;/span>&lt;span>&lt;span style="color:#8ec07c">#pragma omp parallel
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">13&lt;/span>&lt;span>&lt;span style="color:#8ec07c">#pragma omp for
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">14&lt;/span>&lt;span>&lt;span style="color:#8ec07c">&lt;/span>&lt;span style="color:#fe8019">for&lt;/span> (&lt;span style="color:#fabd2f">uint64_t&lt;/span> i &lt;span style="color:#fe8019">=&lt;/span> &lt;span style="color:#d3869b">0&lt;/span>; i &lt;span style="color:#fe8019">&amp;lt;&lt;/span> half; i&lt;span style="color:#fe8019">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">15&lt;/span>&lt;span> &lt;span style="color:#fabd2f">g1_t&lt;/span> y_times_root;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">16&lt;/span>&lt;span> &lt;span style="color:#fabd2f">g1_mul&lt;/span>(&lt;span style="color:#fe8019">&amp;amp;&lt;/span>y_times_root, &lt;span style="color:#fe8019">&amp;amp;&lt;/span>out[i &lt;span style="color:#fe8019">+&lt;/span> half], &lt;span style="color:#fe8019">&amp;amp;&lt;/span>roots[i &lt;span style="color:#fe8019">*&lt;/span> roots_stride]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">17&lt;/span>&lt;span> &lt;span style="color:#fabd2f">g1_sub&lt;/span>(&lt;span style="color:#fe8019">&amp;amp;&lt;/span>out[i &lt;span style="color:#fe8019">+&lt;/span> half], &lt;span style="color:#fe8019">&amp;amp;&lt;/span>out[i], &lt;span style="color:#fe8019">&amp;amp;&lt;/span>y_times_root);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">18&lt;/span>&lt;span> &lt;span style="color:#fabd2f">g1_add_or_dbl&lt;/span>(&lt;span style="color:#fe8019">&amp;amp;&lt;/span>out[i], &lt;span style="color:#fe8019">&amp;amp;&lt;/span>out[i], &lt;span style="color:#fe8019">&amp;amp;&lt;/span>y_times_root);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">19&lt;/span>&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In addition to parallel sections, I also used OpenMP&amp;rsquo;s parallel for-loop, because I noticed it yielded a &lt;strong>5% greater performance&lt;/strong> on my personal machine. Considering the &lt;code>ubuntu-latest&lt;/code> runner in GitHub Actions CI had only two available cores, the halves of the problem were shared among two threads where each ran the for-loop to do arithmetic operations on polynomial &lt;code>G1&lt;/code> points.&lt;/p>
&lt;p>In the above code snippets, &lt;code>fft_g1&lt;/code> calls &lt;code>fft_g1_fast&lt;/code>, which up to scale 16 should at most &lt;code>1 &amp;lt;&amp;lt; 15&lt;/code> times call itself recursively, where each such call will be distributed among the 2 threads. Since we&amp;rsquo;re computing &lt;code>fft_g1&lt;/code> up to scale 8, there should be &lt;code>(1 &amp;lt;&amp;lt; 7) + 1&lt;/code> tasks (not to be confused by OpenMP&amp;rsquo;s &lt;code>task&lt;/code> pragma directive!) for &lt;code>fft_g1_fast&lt;/code> or &lt;code>129&lt;/code> such tasks that will be run in parallel!&lt;/p>
&lt;h2 id="local-c-kzg-benchmark">Local c-kzg benchmark&lt;/h2>
&lt;p>Running on my personal computer with i5-7300HQ (4 threads overclocked at 3.50GHz), all mitigations turned off, and a custom Liquorix kernel, I was able to achieve the following results:&lt;/p>
&lt;table>
&lt;tr>&lt;th>Original c-kzg library&lt;/th>&lt;th>Parallelized c-kzg library&lt;/th>&lt;/tr>
&lt;tr>&lt;td>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 1&lt;/span>&lt;span>$ ./fft_g1_bench
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 2&lt;/span>&lt;span>*** Benchmarking FFT_g1, &lt;span style="color:#d3869b">1&lt;/span> second per test.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 3&lt;/span>&lt;span>fft_g1/scale_4 &lt;span style="color:#d3869b">1729769&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 4&lt;/span>&lt;span>fft_g1/scale_5 &lt;span style="color:#d3869b">4935085&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 5&lt;/span>&lt;span>fft_g1/scale_6 &lt;span style="color:#d3869b">12897731&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 6&lt;/span>&lt;span>fft_g1/scale_7 &lt;span style="color:#d3869b">32022026&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 7&lt;/span>&lt;span>fft_g1/scale_8 &lt;span style="color:#d3869b">76552852&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 8&lt;/span>&lt;span>fft_g1/scale_9 &lt;span style="color:#d3869b">184970057&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 9&lt;/span>&lt;span>fft_g1/scale_10 &lt;span style="color:#d3869b">418273808&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">10&lt;/span>&lt;span>fft_g1/scale_11 &lt;span style="color:#d3869b">919499032&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">11&lt;/span>&lt;span>fft_g1/scale_12 &lt;span style="color:#d3869b">2025633037&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">12&lt;/span>&lt;span>fft_g1/scale_13 &lt;span style="color:#d3869b">4479830518&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">13&lt;/span>&lt;span>fft_g1/scale_14 &lt;span style="color:#d3869b">9754557496&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">14&lt;/span>&lt;span>fft_g1/scale_15 &lt;span style="color:#d3869b">21125613058&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/td>&lt;td>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 1&lt;/span>&lt;span>$ OMP_NUM_THREADS&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#d3869b">4&lt;/span> ./fft_g1_bench
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 2&lt;/span>&lt;span>*** Benchmarking FFT_g1, &lt;span style="color:#d3869b">1&lt;/span> second per test.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 3&lt;/span>&lt;span>fft_g1/scale_4 &lt;span style="color:#d3869b">839454&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 4&lt;/span>&lt;span>fft_g1/scale_5 &lt;span style="color:#d3869b">2378457&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 5&lt;/span>&lt;span>fft_g1/scale_6 &lt;span style="color:#d3869b">6404191&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 6&lt;/span>&lt;span>fft_g1/scale_7 &lt;span style="color:#d3869b">16325966&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 7&lt;/span>&lt;span>fft_g1/scale_8 &lt;span style="color:#d3869b">38141754&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 8&lt;/span>&lt;span>fft_g1/scale_9 &lt;span style="color:#d3869b">90948810&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59"> 9&lt;/span>&lt;span>fft_g1/scale_10 &lt;span style="color:#d3869b">204757690&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">10&lt;/span>&lt;span>fft_g1/scale_11 &lt;span style="color:#d3869b">457509973&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">11&lt;/span>&lt;span>fft_g1/scale_12 &lt;span style="color:#d3869b">1006089135&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">12&lt;/span>&lt;span>fft_g1/scale_13 &lt;span style="color:#d3869b">2240095284&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">13&lt;/span>&lt;span>fft_g1/scale_14 &lt;span style="color:#d3869b">4879448286&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">14&lt;/span>&lt;span>fft_g1/scale_15 &lt;span style="color:#d3869b">10650876381&lt;/span> ns/op
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/td>&lt;/tr>&lt;/table>
&lt;p>That&amp;rsquo;s &lt;strong>twice as fast&lt;/strong> with as little effort as putting in a few pragmas!&lt;/p>
&lt;h2 id="github-actions-ci-benchmarks">GitHub Actions CI benchmarks&lt;/h2>
&lt;p>The &lt;code>fft_g1&lt;/code> benchmark was limited to scale 7 because the overall run time for the job exceeds the 6 hour limit if I were to benchmark it up to scale 16, as Criterion runs each iteration a couple of hundred times to produce more accurate results, and that used to automatically cancel other running CI jobs as jobs submitted to GitHub Actions are limited to 360 minutes.&lt;/p>
&lt;h3 id="benchmarking-blst-from-scratch">Benchmarking blst-from-scratch&lt;/h3>
&lt;p>&lt;img src="https://belijzajac.dev/post-images/from-scratch-github-actions.png" alt="from-scratch-github-actions">&lt;/p>
&lt;p>From the above screenshot we can see that the parallelized version of the library ran &lt;code>1m 28s&lt;/code> shorter than its sequential version, and below are the results of sequential &lt;code>fft_g1&lt;/code> algorithm:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;: Warming up for 3.0000 s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;: Collecting 100 samples in estimated 6.6364 s (200 iterations)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;: Analyzing
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">5&lt;/span>&lt;span>bench_fft_g1 scale: &amp;#39;7&amp;#39; time: [33.423 ms 33.785 ms 34.150 ms]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>of which the average run time for scale 7 was cut down by &lt;code>38.926%&lt;/code> by its parallel counterpart:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;: Warming up for 3.0000 s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;: Collecting 100 samples in estimated 6.3282 s (300 iterations)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;: Analyzing
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">5&lt;/span>&lt;span>bench_fft_g1 scale: &amp;#39;7&amp;#39; time: [20.432 ms 20.634 ms 20.843 ms]
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">6&lt;/span>&lt;span> change: [-39.822% -38.926% -38.001%] (p = 0.00 &amp;lt; 0.05)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">7&lt;/span>&lt;span> Performance has improved.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="benchmarking-ckzg">Benchmarking ckzg&lt;/h3>
&lt;p>&lt;img src="https://belijzajac.dev/post-images/ckzg-github-actions.png" alt="ckzg-github-actions">&lt;/p>
&lt;p>The sequential version of the ckzg library ran &lt;code>2m 7s&lt;/code> faster than the same version of blst-from-scratch because it had other benchmarks that performed faster, though the parallelized version ran &lt;code>1m 2s&lt;/code> faster than its sequential version. Below are the results of the sequantial &lt;code>fft_g1&lt;/code> algorithm:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;: Warming up for 3.0000 s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;: Collecting 100 samples in estimated 6.8313 s (200 iterations)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;: Analyzing
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">5&lt;/span>&lt;span>bench_fft_g1 scale: &amp;#39;7&amp;#39; time: [32.194 ms 32.471 ms 32.760 ms]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Yet the parallel version of the &lt;code>fft_g1&lt;/code> algorithm performed much faster than it did for blst-from-scratch, even though both unparallelized versions for both teams performed evenly:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">1&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">2&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;: Warming up for 3.0000 s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">3&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;: Collecting 100 samples in estimated 5.0701 s (300 iterations)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">4&lt;/span>&lt;span>Benchmarking bench_fft_g1 scale: &amp;#39;7&amp;#39;: Analyzing
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">5&lt;/span>&lt;span>bench_fft_g1 scale: &amp;#39;7&amp;#39; time: [16.854 ms 17.107 ms 17.439 ms]
&lt;/span>&lt;/span>&lt;span style="display:flex; background-color:#3d3d3d">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">6&lt;/span>&lt;span> change: [-48.216% -47.318% -46.306%] (p = 0.00 &amp;lt; 0.05)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59">7&lt;/span>&lt;span> Performance has improved.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="summary">Summary&lt;/h2>
&lt;ul>
&lt;li>OpenMP lets you quickly prototype what is possible to parallelize with the help of CPU profiling tools like Perf&lt;/li>
&lt;li>Criterion is actually a really nice benchmarking tool to measure performance, especially when integrated into CI&lt;/li>
&lt;/ul></description></item></channel></rss>