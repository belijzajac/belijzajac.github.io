<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>llvm on belijzajac.dev</title><link>https://belijzajac.dev/tags/llvm/</link><description>Recent content in llvm on belijzajac.dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 17 Oct 2022 20:55:19 -0500</lastBuildDate><atom:link href="https://belijzajac.dev/tags/llvm/index.xml" rel="self" type="application/rss+xml"/><item><title>WisniaLang: Compiler Project</title><link>https://belijzajac.dev/wisnialang-compiler-project/</link><pubDate>Mon, 17 Oct 2022 20:55:19 -0500</pubDate><guid>https://belijzajac.dev/wisnialang-compiler-project/</guid><description>Introduction For the past 3 years, I have been working on a compiler for an experimental programming language that compiles to native machine code. It focuses on delivering tiny Linux binaries (ELF x86_64) with no LLVM dependency. As a result, what it actually competes with is the LLVM toolchain, on which a large number of other programming languages rely extensively.
Architecture Programming languages that depend on LLVM Before going further, let me get straight to the point:</description></item></channel></rss>